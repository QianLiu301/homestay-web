import {
  __esm,
  __export
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@cloudbase/oauth/dist/esm/utils/encryptlong/index.js
var JSEncrypt, BI_RM, b64map, b64pad, extendStatics, decoder, Hex, decoder$1, Base64, max, ellipsis, reTimeS, reTimeL, dbits, canary, j_lm, lowprimes, lplim, NullExp, Classic, Montgomery, Barrett, BI_FP, BI_RC, rr, vv, rng_psize, rng_state, rng_pool, rng_pptr, t, z, onMouseMoveListener_1, encryptlong_default;
var init_encryptlong = __esm({
  "node_modules/@cloudbase/oauth/dist/esm/utils/encryptlong/index.js"() {
    if (!globalThis.IS_MP_BUILD) {
      let int2char = function(n) {
        return BI_RM.charAt(n);
      }, op_and = function(x, y) {
        return x & y;
      }, op_or = function(x, y) {
        return x | y;
      }, op_xor = function(x, y) {
        return x ^ y;
      }, op_andnot = function(x, y) {
        return x & ~y;
      }, lbit = function(x) {
        if (x == 0) {
          return -1;
        }
        var r = 0;
        if ((x & 65535) == 0) {
          x >>= 16;
          r += 16;
        }
        if ((x & 255) == 0) {
          x >>= 8;
          r += 8;
        }
        if ((x & 15) == 0) {
          x >>= 4;
          r += 4;
        }
        if ((x & 3) == 0) {
          x >>= 2;
          r += 2;
        }
        if ((x & 1) == 0) {
          ++r;
        }
        return r;
      }, cbit = function(x) {
        var r = 0;
        while (x != 0) {
          x &= x - 1;
          ++r;
        }
        return r;
      }, hex2b64 = function(h) {
        var i;
        var c;
        var ret = "";
        for (i = 0; i + 3 <= h.length; i += 3) {
          c = parseInt(h.substring(i, i + 3), 16);
          ret += b64map.charAt(c >> 6) + b64map.charAt(c & 63);
        }
        if (i + 1 == h.length) {
          c = parseInt(h.substring(i, i + 1), 16);
          ret += b64map.charAt(c << 2);
        } else if (i + 2 == h.length) {
          c = parseInt(h.substring(i, i + 2), 16);
          ret += b64map.charAt(c >> 2) + b64map.charAt((c & 3) << 4);
        }
        while ((ret.length & 3) > 0) {
          ret += b64pad;
        }
        return ret;
      }, b64tohex = function(s) {
        var ret = "";
        var i;
        var k = 0;
        var slop = 0;
        for (i = 0; i < s.length; ++i) {
          if (s.charAt(i) == b64pad) {
            break;
          }
          var v = b64map.indexOf(s.charAt(i));
          if (v < 0) {
            continue;
          }
          if (k == 0) {
            ret += int2char(v >> 2);
            slop = v & 3;
            k = 1;
          } else if (k == 1) {
            ret += int2char(slop << 2 | v >> 4);
            slop = v & 15;
            k = 2;
          } else if (k == 2) {
            ret += int2char(slop);
            ret += int2char(v >> 2);
            slop = v & 3;
            k = 3;
          } else {
            ret += int2char(slop << 2 | v >> 4);
            ret += int2char(v & 15);
            k = 0;
          }
        }
        if (k == 1) {
          ret += int2char(slop << 2);
        }
        return ret;
      }, stringCut = function(str, len) {
        if (str.length > len) {
          str = str.substring(0, len) + ellipsis;
        }
        return str;
      }, nbi = function() {
        return new BigInteger(null);
      }, parseBigInt = function(str, r) {
        return new BigInteger(str, r);
      }, am1 = function(i, x, w, j, c, n) {
        while (--n >= 0) {
          var v = x * this[i++] + w[j] + c;
          c = Math.floor(v / 67108864);
          w[j++] = v & 67108863;
        }
        return c;
      }, am2 = function(i, x, w, j, c, n) {
        var xl = x & 32767;
        var xh = x >> 15;
        while (--n >= 0) {
          var l = this[i] & 32767;
          var h = this[i++] >> 15;
          var m = xh * l + h * xl;
          l = xl * l + ((m & 32767) << 15) + w[j] + (c & 1073741823);
          c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
          w[j++] = l & 1073741823;
        }
        return c;
      }, am3 = function(i, x, w, j, c, n) {
        var xl = x & 16383;
        var xh = x >> 14;
        while (--n >= 0) {
          var l = this[i] & 16383;
          var h = this[i++] >> 14;
          var m = xh * l + h * xl;
          l = xl * l + ((m & 16383) << 14) + w[j] + c;
          c = (l >> 28) + (m >> 14) + xh * h;
          w[j++] = l & 268435455;
        }
        return c;
      }, intAt = function(s, i) {
        var c = BI_RC[s.charCodeAt(i)];
        return c == null ? -1 : c;
      }, nbv = function(i) {
        var r = nbi();
        r.fromInt(i);
        return r;
      }, nbits = function(x) {
        var r = 1;
        var t;
        if ((t = x >>> 16) != 0) {
          x = t;
          r += 16;
        }
        if ((t = x >> 8) != 0) {
          x = t;
          r += 8;
        }
        if ((t = x >> 4) != 0) {
          x = t;
          r += 4;
        }
        if ((t = x >> 2) != 0) {
          x = t;
          r += 2;
        }
        if ((t = x >> 1) != 0) {
          x = t;
          r += 1;
        }
        return r;
      }, prng_newstate = function() {
        return new Arcfour();
      }, rng_get_byte = function() {
        if (rng_state == null) {
          rng_state = prng_newstate();
          while (rng_pptr < rng_psize) {
            var random = Math.floor(65536 * Math.random());
            rng_pool[rng_pptr++] = random & 255;
          }
          rng_state.init(rng_pool);
          for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr) {
            rng_pool[rng_pptr] = 0;
          }
          rng_pptr = 0;
        }
        return rng_state.next();
      }, pkcs1pad1 = function(s, n) {
        if (n < s.length + 22) {
          console.error("Message too long for RSA");
          return null;
        }
        var len = n - s.length - 6;
        var filler = "";
        for (var f = 0; f < len; f += 2) {
          filler += "ff";
        }
        var m = "0001" + filler + "00" + s;
        return parseBigInt(m, 16);
      }, pkcs1pad2 = function(s, n) {
        if (n < s.length + 11) {
          console.error("Message too long for RSA");
          return null;
        }
        var ba = [];
        var i = s.length - 1;
        while (i >= 0 && n > 0) {
          var c = s.charCodeAt(i--);
          if (c < 128) {
            ba[--n] = c;
          } else if (c > 127 && c < 2048) {
            ba[--n] = c & 63 | 128;
            ba[--n] = c >> 6 | 192;
          } else {
            ba[--n] = c & 63 | 128;
            ba[--n] = c >> 6 & 63 | 128;
            ba[--n] = c >> 12 | 224;
          }
        }
        ba[--n] = 0;
        var rng = new SecureRandom();
        var x = [];
        while (n > 2) {
          x[0] = 0;
          while (x[0] == 0) {
            rng.nextBytes(x);
          }
          ba[--n] = x[0];
        }
        ba[--n] = 2;
        ba[--n] = 0;
        return new BigInteger(ba);
      }, pkcs1unpad2 = function(d, n) {
        var b = d.toByteArray();
        var i = 0;
        while (i < b.length && b[i] == 0) {
          ++i;
        }
        if (b.length - i != n - 1 || b[i] != 2) {
          return null;
        }
        ++i;
        while (b[i] != 0) {
          if (++i >= b.length) {
            return null;
          }
        }
        var ret = "";
        while (++i < b.length) {
          var c = b[i] & 255;
          if (c < 128) {
            ret += String.fromCharCode(c);
          } else if (c > 191 && c < 224) {
            ret += String.fromCharCode((c & 31) << 6 | b[i + 1] & 63);
            ++i;
          } else {
            ret += String.fromCharCode((c & 15) << 12 | (b[i + 1] & 63) << 6 | b[i + 2] & 63);
            i += 2;
          }
        }
        return ret;
      };
      const navigator = typeof globalThis !== "undefined" ? globalThis.navigator : window.globalThis;
      BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
      b64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      b64pad = "=";
      extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      Hex = {
        decode: function(a) {
          var i;
          if (decoder === void 0) {
            var hex = "0123456789ABCDEF";
            var ignore = " \f\n\r	 \u2028\u2029";
            decoder = {};
            for (i = 0; i < 16; ++i) {
              decoder[hex.charAt(i)] = i;
            }
            hex = hex.toLowerCase();
            for (i = 10; i < 16; ++i) {
              decoder[hex.charAt(i)] = i;
            }
            for (i = 0; i < ignore.length; ++i) {
              decoder[ignore.charAt(i)] = -1;
            }
          }
          var out = [];
          var bits = 0;
          var char_count = 0;
          for (i = 0; i < a.length; ++i) {
            var c = a.charAt(i);
            if (c == "=") {
              break;
            }
            c = decoder[c];
            if (c == -1) {
              continue;
            }
            if (c === void 0) {
              throw new Error("Illegal character at offset " + i);
            }
            bits |= c;
            if (++char_count >= 2) {
              out[out.length] = bits;
              bits = 0;
              char_count = 0;
            } else {
              bits <<= 4;
            }
          }
          if (char_count) {
            throw new Error("Hex encoding incomplete: 4 bits missing");
          }
          return out;
        }
      };
      Base64 = {
        decode: function(a) {
          var i;
          if (decoder$1 === void 0) {
            var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            var ignore = "= \f\n\r	 \u2028\u2029";
            decoder$1 = /* @__PURE__ */ Object.create(null);
            for (i = 0; i < 64; ++i) {
              decoder$1[b64.charAt(i)] = i;
            }
            for (i = 0; i < ignore.length; ++i) {
              decoder$1[ignore.charAt(i)] = -1;
            }
          }
          var out = [];
          var bits = 0;
          var char_count = 0;
          for (i = 0; i < a.length; ++i) {
            var c = a.charAt(i);
            if (c == "=") {
              break;
            }
            c = decoder$1[c];
            if (c == -1) {
              continue;
            }
            if (c === void 0) {
              throw new Error("Illegal character at offset " + i);
            }
            bits |= c;
            if (++char_count >= 4) {
              out[out.length] = bits >> 16;
              out[out.length] = bits >> 8 & 255;
              out[out.length] = bits & 255;
              bits = 0;
              char_count = 0;
            } else {
              bits <<= 6;
            }
          }
          switch (char_count) {
            case 1:
              throw new Error("Base64 encoding incomplete: at least 2 bits missing");
            case 2:
              out[out.length] = bits >> 10;
              break;
            case 3:
              out[out.length] = bits >> 16;
              out[out.length] = bits >> 8 & 255;
              break;
          }
          return out;
        },
        re: /-----BEGIN [^-]+-----([A-Za-z0-9+\/=\s]+)-----END [^-]+-----|begin-base64[^\n]+\n([A-Za-z0-9+\/=\s]+)====/,
        unarmor: function(a) {
          var m = Base64.re.exec(a);
          if (m) {
            if (m[1]) {
              a = m[1];
            } else if (m[2]) {
              a = m[2];
            } else {
              throw new Error("RegExp out of sync");
            }
          }
          return Base64.decode(a);
        }
      };
      max = 1e13;
      class Int10 {
        constructor(value) {
          this.buf = [+value || 0];
        }
        mulAdd(m, c) {
          var b = this.buf;
          var l = b.length;
          var i;
          var t;
          for (i = 0; i < l; ++i) {
            t = b[i] * m + c;
            if (t < max) {
              c = 0;
            } else {
              c = 0 | t / max;
              t -= c * max;
            }
            b[i] = t;
          }
          if (c > 0) {
            b[i] = c;
          }
        }
        sub(c) {
          var b = this.buf;
          var l = b.length;
          var i;
          var t;
          for (i = 0; i < l; ++i) {
            t = b[i] - c;
            if (t < 0) {
              t += max;
              c = 1;
            } else {
              c = 0;
            }
            b[i] = t;
          }
          while (b[b.length - 1] === 0) {
            b.pop();
          }
        }
        toString(base) {
          if ((base || 10) != 10) {
            throw new Error("only base 10 is supported");
          }
          var b = this.buf;
          var s = b[b.length - 1].toString();
          for (var i = b.length - 2; i >= 0; --i) {
            s += (max + b[i]).toString().substring(1);
          }
          return s;
        }
        valueOf() {
          var b = this.buf;
          var v = 0;
          for (var i = b.length - 1; i >= 0; --i) {
            v = v * max + b[i];
          }
          return v;
        }
        simplify() {
          var b = this.buf;
          return b.length == 1 ? b[0] : this;
        }
      }
      ellipsis = "…";
      reTimeS = /^(\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/;
      reTimeL = /^(\d\d\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/;
      class Stream {
        constructor(enc, pos) {
          this.hexDigits = "0123456789ABCDEF";
          if (enc instanceof Stream) {
            this.enc = enc.enc;
            this.pos = enc.pos;
          } else {
            this.enc = enc;
            this.pos = pos;
          }
        }
        get(pos) {
          if (pos === void 0) {
            pos = this.pos++;
          }
          if (pos >= this.enc.length) {
            throw new Error("Requesting byte offset " + pos + " on a stream of length " + this.enc.length);
          }
          return "string" === typeof this.enc ? this.enc.charCodeAt(pos) : this.enc[pos];
        }
        hexByte(b) {
          return this.hexDigits.charAt(b >> 4 & 15) + this.hexDigits.charAt(b & 15);
        }
        hexDump(start, end, raw) {
          var s = "";
          for (var i = start; i < end; ++i) {
            s += this.hexByte(this.get(i));
            if (raw !== true) {
              switch (i & 15) {
                case 7:
                  s += "  ";
                  break;
                case 15:
                  s += "\n";
                  break;
                default:
                  s += " ";
              }
            }
          }
          return s;
        }
        isASCII(start, end) {
          for (var i = start; i < end; ++i) {
            var c = this.get(i);
            if (c < 32 || c > 176) {
              return false;
            }
          }
          return true;
        }
        parseStringISO(start, end) {
          var s = "";
          for (var i = start; i < end; ++i) {
            s += String.fromCharCode(this.get(i));
          }
          return s;
        }
        parseStringUTF(start, end) {
          var s = "";
          for (var i = start; i < end; ) {
            var c = this.get(i++);
            if (c < 128) {
              s += String.fromCharCode(c);
            } else if (c > 191 && c < 224) {
              s += String.fromCharCode((c & 31) << 6 | this.get(i++) & 63);
            } else {
              s += String.fromCharCode((c & 15) << 12 | (this.get(i++) & 63) << 6 | this.get(i++) & 63);
            }
          }
          return s;
        }
        parseStringBMP(start, end) {
          var str = "";
          var hi;
          var lo;
          for (var i = start; i < end; ) {
            hi = this.get(i++);
            lo = this.get(i++);
            str += String.fromCharCode(hi << 8 | lo);
          }
          return str;
        }
        parseTime(start, end, shortYear) {
          var s = this.parseStringISO(start, end);
          var m = (shortYear ? reTimeS : reTimeL).exec(s);
          if (!m) {
            return "Unrecognized time: " + s;
          }
          if (shortYear) {
            m[1] = +m[1];
            m[1] += +m[1] < 70 ? 2e3 : 1900;
          }
          s = m[1] + "-" + m[2] + "-" + m[3] + " " + m[4];
          if (m[5]) {
            s += ":" + m[5];
            if (m[6]) {
              s += ":" + m[6];
              if (m[7]) {
                s += "." + m[7];
              }
            }
          }
          if (m[8]) {
            s += " UTC";
            if (m[8] != "Z") {
              s += m[8];
              if (m[9]) {
                s += ":" + m[9];
              }
            }
          }
          return s;
        }
        parseInteger(start, end) {
          var v = this.get(start);
          var neg = v > 127;
          var pad = neg ? 255 : 0;
          var len;
          var s = "";
          while (v == pad && ++start < end) {
            v = this.get(start);
          }
          len = end - start;
          if (len === 0) {
            return neg ? -1 : 0;
          }
          if (len > 4) {
            s = v;
            len <<= 3;
            while (((+s ^ pad) & 128) == 0) {
              s = +s << 1;
              --len;
            }
            s = "(" + len + " bit)\n";
          }
          if (neg) {
            v = v - 256;
          }
          var n = new Int10(v);
          for (var i = start + 1; i < end; ++i) {
            n.mulAdd(256, this.get(i));
          }
          return s + n.toString();
        }
        parseBitString(start, end, maxLength) {
          var unusedBit = this.get(start);
          var lenBit = (end - start - 1 << 3) - unusedBit;
          var intro = "(" + lenBit + " bit)\n";
          var s = "";
          for (var i = start + 1; i < end; ++i) {
            var b = this.get(i);
            var skip = i == end - 1 ? unusedBit : 0;
            for (var j = 7; j >= skip; --j) {
              s += b >> j & 1 ? "1" : "0";
            }
            if (s.length > maxLength) {
              return intro + stringCut(s, maxLength);
            }
          }
          return intro + s;
        }
        parseOctetString(start, end, maxLength) {
          if (this.isASCII(start, end)) {
            return stringCut(this.parseStringISO(start, end), maxLength);
          }
          var len = end - start;
          var s = "(" + len + " byte)\n";
          maxLength /= 2;
          if (len > maxLength) {
            end = start + maxLength;
          }
          for (var i = start; i < end; ++i) {
            s += this.hexByte(this.get(i));
          }
          if (len > maxLength) {
            s += ellipsis;
          }
          return s;
        }
        parseOID(start, end, maxLength) {
          var s = "";
          var n = new Int10();
          var bits = 0;
          for (var i = start; i < end; ++i) {
            var v = this.get(i);
            n.mulAdd(128, v & 127);
            bits += 7;
            if (!(v & 128)) {
              if (s === "") {
                n = n.simplify();
                if (n instanceof Int10) {
                  n.sub(80);
                  s = "2." + n.toString();
                } else {
                  var m = n < 80 ? n < 40 ? 0 : 1 : 2;
                  s = m + "." + (n - m * 40);
                }
              } else {
                s += "." + n.toString();
              }
              if (s.length > maxLength) {
                return stringCut(s, maxLength);
              }
              n = new Int10();
              bits = 0;
            }
          }
          if (bits > 0) {
            s += ".incomplete";
          }
          return s;
        }
      }
      class ASN1 {
        constructor(stream, header, length, tag, sub) {
          if (!(tag instanceof ASN1Tag)) {
            throw new Error("Invalid tag value.");
          }
          this.stream = stream;
          this.header = header;
          this.length = length;
          this.tag = tag;
          this.sub = sub;
        }
        typeName() {
          switch (this.tag.tagClass) {
            case 0:
              switch (this.tag.tagNumber) {
                case 0:
                  return "EOC";
                case 1:
                  return "BOOLEAN";
                case 2:
                  return "INTEGER";
                case 3:
                  return "BIT_STRING";
                case 4:
                  return "OCTET_STRING";
                case 5:
                  return "NULL";
                case 6:
                  return "OBJECT_IDENTIFIER";
                case 7:
                  return "ObjectDescriptor";
                case 8:
                  return "EXTERNAL";
                case 9:
                  return "REAL";
                case 10:
                  return "ENUMERATED";
                case 11:
                  return "EMBEDDED_PDV";
                case 12:
                  return "UTF8String";
                case 16:
                  return "SEQUENCE";
                case 17:
                  return "SET";
                case 18:
                  return "NumericString";
                case 19:
                  return "PrintableString";
                case 20:
                  return "TeletexString";
                case 21:
                  return "VideotexString";
                case 22:
                  return "IA5String";
                case 23:
                  return "UTCTime";
                case 24:
                  return "GeneralizedTime";
                case 25:
                  return "GraphicString";
                case 26:
                  return "VisibleString";
                case 27:
                  return "GeneralString";
                case 28:
                  return "UniversalString";
                case 30:
                  return "BMPString";
              }
              return "Universal_" + this.tag.tagNumber.toString();
            case 1:
              return "Application_" + this.tag.tagNumber.toString();
            case 2:
              return "[" + this.tag.tagNumber.toString() + "]";
            case 3:
              return "Private_" + this.tag.tagNumber.toString();
          }
        }
        content(maxLength) {
          if (this.tag === void 0) {
            return null;
          }
          if (maxLength === void 0) {
            maxLength = Infinity;
          }
          var content = this.posContent();
          var len = Math.abs(this.length);
          if (!this.tag.isUniversal()) {
            if (this.sub !== null) {
              return "(" + this.sub.length + " elem)";
            }
            return this.stream.parseOctetString(content, content + len, maxLength);
          }
          switch (this.tag.tagNumber) {
            case 1:
              return this.stream.get(content) === 0 ? "false" : "true";
            case 2:
              return this.stream.parseInteger(content, content + len);
            case 3:
              return this.sub ? "(" + this.sub.length + " elem)" : this.stream.parseBitString(content, content + len, maxLength);
            case 4:
              return this.sub ? "(" + this.sub.length + " elem)" : this.stream.parseOctetString(content, content + len, maxLength);
            case 6:
              return this.stream.parseOID(content, content + len, maxLength);
            case 16:
            case 17:
              if (this.sub !== null) {
                return "(" + this.sub.length + " elem)";
              } else {
                return "(no elem)";
              }
            case 12:
              return stringCut(this.stream.parseStringUTF(content, content + len), maxLength);
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 26:
              return stringCut(this.stream.parseStringISO(content, content + len), maxLength);
            case 30:
              return stringCut(this.stream.parseStringBMP(content, content + len), maxLength);
            case 23:
            case 24:
              return this.stream.parseTime(content, content + len, this.tag.tagNumber == 23);
          }
          return null;
        }
        toString() {
          return this.typeName() + "@" + this.stream.pos + "[header:" + this.header + ",length:" + this.length + ",sub:" + (this.sub === null ? "null" : this.sub.length) + "]";
        }
        toPrettyString(indent) {
          if (indent === void 0) {
            indent = "";
          }
          var s = indent + this.typeName() + " @" + this.stream.pos;
          if (this.length >= 0) {
            s += "+";
          }
          s += this.length;
          if (this.tag.tagConstructed) {
            s += " (constructed)";
          } else if (this.tag.isUniversal() && (this.tag.tagNumber == 3 || this.tag.tagNumber == 4) && this.sub !== null) {
            s += " (encapsulates)";
          }
          s += "\n";
          if (this.sub !== null) {
            indent += "  ";
            for (var i = 0, max2 = this.sub.length; i < max2; ++i) {
              s += this.sub[i].toPrettyString(indent);
            }
          }
          return s;
        }
        posStart() {
          return this.stream.pos;
        }
        posContent() {
          return this.stream.pos + this.header;
        }
        posEnd() {
          return this.stream.pos + this.header + Math.abs(this.length);
        }
        toHexString() {
          return this.stream.hexDump(this.posStart(), this.posEnd(), true);
        }
        static decodeLength(stream) {
          var buf = stream.get();
          var len = buf & 127;
          if (len == buf) {
            return len;
          }
          if (len > 6) {
            throw new Error("Length over 48 bits not supported at position " + (stream.pos - 1));
          }
          if (len === 0) {
            return null;
          }
          buf = 0;
          for (var i = 0; i < len; ++i) {
            buf = buf * 256 + stream.get();
          }
          return buf;
        }
        getHexStringValue() {
          var hexString = this.toHexString();
          var offset = this.header * 2;
          var length = this.length * 2;
          return hexString.substr(offset, length);
        }
        static decode(str) {
          var stream;
          if (!(str instanceof Stream)) {
            stream = new Stream(str, 0);
          } else {
            stream = str;
          }
          var streamStart = new Stream(stream);
          var tag = new ASN1Tag(stream);
          var len = ASN1.decodeLength(stream);
          var start = stream.pos;
          var header = start - streamStart.pos;
          var sub = null;
          var getSub = function() {
            var ret = [];
            if (len !== null) {
              var end = start + len;
              while (stream.pos < end) {
                ret[ret.length] = ASN1.decode(stream);
              }
              if (stream.pos != end) {
                throw new Error("Content size is not correct for container starting at offset " + start);
              }
            } else {
              try {
                for (; ; ) {
                  var s = ASN1.decode(stream);
                  if (s.tag.isEOC()) {
                    break;
                  }
                  ret[ret.length] = s;
                }
                len = start - stream.pos;
              } catch (e) {
                throw new Error("Exception while decoding undefined length content: " + e);
              }
            }
            return ret;
          };
          if (tag.tagConstructed) {
            sub = getSub();
          } else if (tag.isUniversal() && (tag.tagNumber == 3 || tag.tagNumber == 4)) {
            try {
              if (tag.tagNumber == 3) {
                if (stream.get() != 0) {
                  throw new Error("BIT STRINGs with unused bits cannot encapsulate.");
                }
              }
              sub = getSub();
              for (var i = 0; i < sub.length; ++i) {
                if (sub[i].tag.isEOC()) {
                  throw new Error("EOC is not supposed to be actual content.");
                }
              }
            } catch (e) {
              sub = null;
            }
          }
          if (sub === null) {
            if (len === null) {
              throw new Error("We can't skip over an invalid tag with undefined length at offset " + start);
            }
            stream.pos = start + Math.abs(len);
          }
          return new ASN1(streamStart, header, len, tag, sub);
        }
      }
      class ASN1Tag {
        constructor(stream) {
          var buf = stream.get();
          this.tagClass = buf >> 6;
          this.tagConstructed = (buf & 32) !== 0;
          this.tagNumber = buf & 31;
          if (this.tagNumber == 31) {
            var n = new Int10();
            do {
              buf = stream.get();
              n.mulAdd(128, buf & 127);
            } while (buf & 128);
            this.tagNumber = n.simplify();
          }
        }
        isUniversal() {
          return this.tagClass === 0;
        }
        isEOC() {
          return this.tagClass === 0 && this.tagNumber === 0;
        }
      }
      canary = 244837814094590;
      j_lm = (canary & 16777215) == 15715070;
      lowprimes = [
        2,
        3,
        5,
        7,
        11,
        13,
        17,
        19,
        23,
        29,
        31,
        37,
        41,
        43,
        47,
        53,
        59,
        61,
        67,
        71,
        73,
        79,
        83,
        89,
        97,
        101,
        103,
        107,
        109,
        113,
        127,
        131,
        137,
        139,
        149,
        151,
        157,
        163,
        167,
        173,
        179,
        181,
        191,
        193,
        197,
        199,
        211,
        223,
        227,
        229,
        233,
        239,
        241,
        251,
        257,
        263,
        269,
        271,
        277,
        281,
        283,
        293,
        307,
        311,
        313,
        317,
        331,
        337,
        347,
        349,
        353,
        359,
        367,
        373,
        379,
        383,
        389,
        397,
        401,
        409,
        419,
        421,
        431,
        433,
        439,
        443,
        449,
        457,
        461,
        463,
        467,
        479,
        487,
        491,
        499,
        503,
        509,
        521,
        523,
        541,
        547,
        557,
        563,
        569,
        571,
        577,
        587,
        593,
        599,
        601,
        607,
        613,
        617,
        619,
        631,
        641,
        643,
        647,
        653,
        659,
        661,
        673,
        677,
        683,
        691,
        701,
        709,
        719,
        727,
        733,
        739,
        743,
        751,
        757,
        761,
        769,
        773,
        787,
        797,
        809,
        811,
        821,
        823,
        827,
        829,
        839,
        853,
        857,
        859,
        863,
        877,
        881,
        883,
        887,
        907,
        911,
        919,
        929,
        937,
        941,
        947,
        953,
        967,
        971,
        977,
        983,
        991,
        997
      ];
      lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
      class BigInteger {
        constructor(a, b, c) {
          if (a != null) {
            if ("number" == typeof a) {
              this.fromNumber(a, b, c);
            } else if (b == null && "string" != typeof a) {
              this.fromString(a, 256);
            } else {
              this.fromString(a, b);
            }
          }
        }
        toString(b) {
          if (this.s < 0) {
            return "-" + this.negate().toString(b);
          }
          var k;
          if (b == 16) {
            k = 4;
          } else if (b == 8) {
            k = 3;
          } else if (b == 2) {
            k = 1;
          } else if (b == 32) {
            k = 5;
          } else if (b == 4) {
            k = 2;
          } else {
            return this.toRadix(b);
          }
          var km = (1 << k) - 1;
          var d;
          var m = false;
          var r = "";
          var i = this.t;
          var p = this.DB - i * this.DB % k;
          if (i-- > 0) {
            if (p < this.DB && (d = this[i] >> p) > 0) {
              m = true;
              r = int2char(d);
            }
            while (i >= 0) {
              if (p < k) {
                d = (this[i] & (1 << p) - 1) << k - p;
                d |= this[--i] >> (p += this.DB - k);
              } else {
                d = this[i] >> (p -= k) & km;
                if (p <= 0) {
                  p += this.DB;
                  --i;
                }
              }
              if (d > 0) {
                m = true;
              }
              if (m) {
                r += int2char(d);
              }
            }
          }
          return m ? r : "0";
        }
        negate() {
          var r = nbi();
          BigInteger.ZERO.subTo(this, r);
          return r;
        }
        abs() {
          return this.s < 0 ? this.negate() : this;
        }
        compareTo(a) {
          var r = this.s - a.s;
          if (r != 0) {
            return r;
          }
          var i = this.t;
          r = i - a.t;
          if (r != 0) {
            return this.s < 0 ? -r : r;
          }
          while (--i >= 0) {
            if ((r = this[i] - a[i]) != 0) {
              return r;
            }
          }
          return 0;
        }
        bitLength() {
          if (this.t <= 0) {
            return 0;
          }
          return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
        }
        mod(a) {
          var r = nbi();
          this.abs().divRemTo(a, null, r);
          if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) {
            a.subTo(r, r);
          }
          return r;
        }
        modPowInt(e, m) {
          var z;
          if (e < 256 || m.isEven()) {
            z = new Classic(m);
          } else {
            z = new Montgomery(m);
          }
          return this.exp(e, z);
        }
        clone() {
          var r = nbi();
          this.copyTo(r);
          return r;
        }
        intValue() {
          if (this.s < 0) {
            if (this.t == 1) {
              return this[0] - this.DV;
            } else if (this.t == 0) {
              return -1;
            }
          } else if (this.t == 1) {
            return this[0];
          } else if (this.t == 0) {
            return 0;
          }
          return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
        }
        byteValue() {
          return this.t == 0 ? this.s : this[0] << 24 >> 24;
        }
        shortValue() {
          return this.t == 0 ? this.s : this[0] << 16 >> 16;
        }
        signum() {
          if (this.s < 0) {
            return -1;
          } else if (this.t <= 0 || this.t == 1 && this[0] <= 0) {
            return 0;
          } else {
            return 1;
          }
        }
        toByteArray() {
          var i = this.t;
          var r = [];
          r[0] = this.s;
          var p = this.DB - i * this.DB % 8;
          var d;
          var k = 0;
          if (i-- > 0) {
            if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p) {
              r[k++] = d | this.s << this.DB - p;
            }
            while (i >= 0) {
              if (p < 8) {
                d = (this[i] & (1 << p) - 1) << 8 - p;
                d |= this[--i] >> (p += this.DB - 8);
              } else {
                d = this[i] >> (p -= 8) & 255;
                if (p <= 0) {
                  p += this.DB;
                  --i;
                }
              }
              if ((d & 128) != 0) {
                d |= -256;
              }
              if (k == 0 && (this.s & 128) != (d & 128)) {
                ++k;
              }
              if (k > 0 || d != this.s) {
                r[k++] = d;
              }
            }
          }
          return r;
        }
        equals(a) {
          return this.compareTo(a) == 0;
        }
        min(a) {
          return this.compareTo(a) < 0 ? this : a;
        }
        max(a) {
          return this.compareTo(a) > 0 ? this : a;
        }
        and(a) {
          var r = nbi();
          this.bitwiseTo(a, op_and, r);
          return r;
        }
        or(a) {
          var r = nbi();
          this.bitwiseTo(a, op_or, r);
          return r;
        }
        xor(a) {
          var r = nbi();
          this.bitwiseTo(a, op_xor, r);
          return r;
        }
        andNot(a) {
          var r = nbi();
          this.bitwiseTo(a, op_andnot, r);
          return r;
        }
        not() {
          var r = nbi();
          for (var i = 0; i < this.t; ++i) {
            r[i] = this.DM & ~this[i];
          }
          r.t = this.t;
          r.s = ~this.s;
          return r;
        }
        shiftLeft(n) {
          var r = nbi();
          if (n < 0) {
            this.rShiftTo(-n, r);
          } else {
            this.lShiftTo(n, r);
          }
          return r;
        }
        shiftRight(n) {
          var r = nbi();
          if (n < 0) {
            this.lShiftTo(-n, r);
          } else {
            this.rShiftTo(n, r);
          }
          return r;
        }
        getLowestSetBit() {
          for (var i = 0; i < this.t; ++i) {
            if (this[i] != 0) {
              return i * this.DB + lbit(this[i]);
            }
          }
          if (this.s < 0) {
            return this.t * this.DB;
          }
          return -1;
        }
        bitCount() {
          var r = 0;
          var x = this.s & this.DM;
          for (var i = 0; i < this.t; ++i) {
            r += cbit(this[i] ^ x);
          }
          return r;
        }
        testBit(n) {
          var j = Math.floor(n / this.DB);
          if (j >= this.t) {
            return this.s != 0;
          }
          return (this[j] & 1 << n % this.DB) != 0;
        }
        setBit(n) {
          return this.changeBit(n, op_or);
        }
        clearBit(n) {
          return this.changeBit(n, op_andnot);
        }
        flipBit(n) {
          return this.changeBit(n, op_xor);
        }
        add(a) {
          var r = nbi();
          this.addTo(a, r);
          return r;
        }
        subtract(a) {
          var r = nbi();
          this.subTo(a, r);
          return r;
        }
        multiply(a) {
          var r = nbi();
          this.multiplyTo(a, r);
          return r;
        }
        divide(a) {
          var r = nbi();
          this.divRemTo(a, r, null);
          return r;
        }
        remainder(a) {
          var r = nbi();
          this.divRemTo(a, null, r);
          return r;
        }
        divideAndRemainder(a) {
          var q = nbi();
          var r = nbi();
          this.divRemTo(a, q, r);
          return [q, r];
        }
        modPow(e, m) {
          var i = e.bitLength();
          var k;
          var r = nbv(1);
          var z;
          if (i <= 0) {
            return r;
          } else if (i < 18) {
            k = 1;
          } else if (i < 48) {
            k = 3;
          } else if (i < 144) {
            k = 4;
          } else if (i < 768) {
            k = 5;
          } else {
            k = 6;
          }
          if (i < 8) {
            z = new Classic(m);
          } else if (m.isEven()) {
            z = new Barrett(m);
          } else {
            z = new Montgomery(m);
          }
          var g = [];
          var n = 3;
          var k1 = k - 1;
          var km = (1 << k) - 1;
          g[1] = z.convert(this);
          if (k > 1) {
            var g2 = nbi();
            z.sqrTo(g[1], g2);
            while (n <= km) {
              g[n] = nbi();
              z.mulTo(g2, g[n - 2], g[n]);
              n += 2;
            }
          }
          var j = e.t - 1;
          var w;
          var is1 = true;
          var r2 = nbi();
          var t;
          i = nbits(e[j]) - 1;
          while (j >= 0) {
            if (i >= k1) {
              w = e[j] >> i - k1 & km;
            } else {
              w = (e[j] & (1 << i + 1) - 1) << k1 - i;
              if (j > 0) {
                w |= e[j - 1] >> this.DB + i - k1;
              }
            }
            n = k;
            while ((w & 1) == 0) {
              w >>= 1;
              --n;
            }
            if ((i -= n) < 0) {
              i += this.DB;
              --j;
            }
            if (is1) {
              g[w].copyTo(r);
              is1 = false;
            } else {
              while (n > 1) {
                z.sqrTo(r, r2);
                z.sqrTo(r2, r);
                n -= 2;
              }
              if (n > 0) {
                z.sqrTo(r, r2);
              } else {
                t = r;
                r = r2;
                r2 = t;
              }
              z.mulTo(r2, g[w], r);
            }
            while (j >= 0 && (e[j] & 1 << i) == 0) {
              z.sqrTo(r, r2);
              t = r;
              r = r2;
              r2 = t;
              if (--i < 0) {
                i = this.DB - 1;
                --j;
              }
            }
          }
          return z.revert(r);
        }
        modInverse(m) {
          var ac = m.isEven();
          if (this.isEven() && ac || m.signum() == 0) {
            return BigInteger.ZERO;
          }
          var u = m.clone();
          var v = this.clone();
          var a = nbv(1);
          var b = nbv(0);
          var c = nbv(0);
          var d = nbv(1);
          while (u.signum() != 0) {
            while (u.isEven()) {
              u.rShiftTo(1, u);
              if (ac) {
                if (!a.isEven() || !b.isEven()) {
                  a.addTo(this, a);
                  b.subTo(m, b);
                }
                a.rShiftTo(1, a);
              } else if (!b.isEven()) {
                b.subTo(m, b);
              }
              b.rShiftTo(1, b);
            }
            while (v.isEven()) {
              v.rShiftTo(1, v);
              if (ac) {
                if (!c.isEven() || !d.isEven()) {
                  c.addTo(this, c);
                  d.subTo(m, d);
                }
                c.rShiftTo(1, c);
              } else if (!d.isEven()) {
                d.subTo(m, d);
              }
              d.rShiftTo(1, d);
            }
            if (u.compareTo(v) >= 0) {
              u.subTo(v, u);
              if (ac) {
                a.subTo(c, a);
              }
              b.subTo(d, b);
            } else {
              v.subTo(u, v);
              if (ac) {
                c.subTo(a, c);
              }
              d.subTo(b, d);
            }
          }
          if (v.compareTo(BigInteger.ONE) != 0) {
            return BigInteger.ZERO;
          }
          if (d.compareTo(m) >= 0) {
            return d.subtract(m);
          }
          if (d.signum() < 0) {
            d.addTo(m, d);
          } else {
            return d;
          }
          if (d.signum() < 0) {
            return d.add(m);
          } else {
            return d;
          }
        }
        pow(e) {
          return this.exp(e, new NullExp());
        }
        gcd(a) {
          var x = this.s < 0 ? this.negate() : this.clone();
          var y = a.s < 0 ? a.negate() : a.clone();
          if (x.compareTo(y) < 0) {
            var t = x;
            x = y;
            y = t;
          }
          var i = x.getLowestSetBit();
          var g = y.getLowestSetBit();
          if (g < 0) {
            return x;
          }
          if (i < g) {
            g = i;
          }
          if (g > 0) {
            x.rShiftTo(g, x);
            y.rShiftTo(g, y);
          }
          while (x.signum() > 0) {
            if ((i = x.getLowestSetBit()) > 0) {
              x.rShiftTo(i, x);
            }
            if ((i = y.getLowestSetBit()) > 0) {
              y.rShiftTo(i, y);
            }
            if (x.compareTo(y) >= 0) {
              x.subTo(y, x);
              x.rShiftTo(1, x);
            } else {
              y.subTo(x, y);
              y.rShiftTo(1, y);
            }
          }
          if (g > 0) {
            y.lShiftTo(g, y);
          }
          return y;
        }
        isProbablePrime(t) {
          var i;
          var x = this.abs();
          if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
            for (i = 0; i < lowprimes.length; ++i) {
              if (x[0] == lowprimes[i]) {
                return true;
              }
            }
            return false;
          }
          if (x.isEven()) {
            return false;
          }
          i = 1;
          while (i < lowprimes.length) {
            var m = lowprimes[i];
            var j = i + 1;
            while (j < lowprimes.length && m < lplim) {
              m *= lowprimes[j++];
            }
            m = x.modInt(m);
            while (i < j) {
              if (m % lowprimes[i++] == 0) {
                return false;
              }
            }
          }
          return x.millerRabin(t);
        }
        copyTo(r) {
          for (var i = this.t - 1; i >= 0; --i) {
            r[i] = this[i];
          }
          r.t = this.t;
          r.s = this.s;
        }
        fromInt(x) {
          this.t = 1;
          this.s = x < 0 ? -1 : 0;
          if (x > 0) {
            this[0] = x;
          } else if (x < -1) {
            this[0] = x + this.DV;
          } else {
            this.t = 0;
          }
        }
        fromString(s, b) {
          var k;
          if (b == 16) {
            k = 4;
          } else if (b == 8) {
            k = 3;
          } else if (b == 256) {
            k = 8;
          } else if (b == 2) {
            k = 1;
          } else if (b == 32) {
            k = 5;
          } else if (b == 4) {
            k = 2;
          } else {
            this.fromRadix(s, b);
            return;
          }
          this.t = 0;
          this.s = 0;
          var i = s.length;
          var mi = false;
          var sh = 0;
          while (--i >= 0) {
            var x = k == 8 ? +s[i] & 255 : intAt(s, i);
            if (x < 0) {
              if (s.charAt(i) == "-") {
                mi = true;
              }
              continue;
            }
            mi = false;
            if (sh == 0) {
              this[this.t++] = x;
            } else if (sh + k > this.DB) {
              this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
              this[this.t++] = x >> this.DB - sh;
            } else {
              this[this.t - 1] |= x << sh;
            }
            sh += k;
            if (sh >= this.DB) {
              sh -= this.DB;
            }
          }
          if (k == 8 && (+s[0] & 128) != 0) {
            this.s = -1;
            if (sh > 0) {
              this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
            }
          }
          this.clamp();
          if (mi) {
            BigInteger.ZERO.subTo(this, this);
          }
        }
        clamp() {
          var c = this.s & this.DM;
          while (this.t > 0 && this[this.t - 1] == c) {
            --this.t;
          }
        }
        dlShiftTo(n, r) {
          var i;
          for (i = this.t - 1; i >= 0; --i) {
            r[i + n] = this[i];
          }
          for (i = n - 1; i >= 0; --i) {
            r[i] = 0;
          }
          r.t = this.t + n;
          r.s = this.s;
        }
        drShiftTo(n, r) {
          for (var i = n; i < this.t; ++i) {
            r[i - n] = this[i];
          }
          r.t = Math.max(this.t - n, 0);
          r.s = this.s;
        }
        lShiftTo(n, r) {
          var bs = n % this.DB;
          var cbs = this.DB - bs;
          var bm = (1 << cbs) - 1;
          var ds = Math.floor(n / this.DB);
          var c = this.s << bs & this.DM;
          for (var i = this.t - 1; i >= 0; --i) {
            r[i + ds + 1] = this[i] >> cbs | c;
            c = (this[i] & bm) << bs;
          }
          for (var i = ds - 1; i >= 0; --i) {
            r[i] = 0;
          }
          r[ds] = c;
          r.t = this.t + ds + 1;
          r.s = this.s;
          r.clamp();
        }
        rShiftTo(n, r) {
          r.s = this.s;
          var ds = Math.floor(n / this.DB);
          if (ds >= this.t) {
            r.t = 0;
            return;
          }
          var bs = n % this.DB;
          var cbs = this.DB - bs;
          var bm = (1 << bs) - 1;
          r[0] = this[ds] >> bs;
          for (var i = ds + 1; i < this.t; ++i) {
            r[i - ds - 1] |= (this[i] & bm) << cbs;
            r[i - ds] = this[i] >> bs;
          }
          if (bs > 0) {
            r[this.t - ds - 1] |= (this.s & bm) << cbs;
          }
          r.t = this.t - ds;
          r.clamp();
        }
        subTo(a, r) {
          var i = 0;
          var c = 0;
          var m = Math.min(a.t, this.t);
          while (i < m) {
            c += this[i] - a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          if (a.t < this.t) {
            c -= a.s;
            while (i < this.t) {
              c += this[i];
              r[i++] = c & this.DM;
              c >>= this.DB;
            }
            c += this.s;
          } else {
            c += this.s;
            while (i < a.t) {
              c -= a[i];
              r[i++] = c & this.DM;
              c >>= this.DB;
            }
            c -= a.s;
          }
          r.s = c < 0 ? -1 : 0;
          if (c < -1) {
            r[i++] = this.DV + c;
          } else if (c > 0) {
            r[i++] = c;
          }
          r.t = i;
          r.clamp();
        }
        multiplyTo(a, r) {
          var x = this.abs();
          var y = a.abs();
          var i = x.t;
          r.t = i + y.t;
          while (--i >= 0) {
            r[i] = 0;
          }
          for (i = 0; i < y.t; ++i) {
            r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
          }
          r.s = 0;
          r.clamp();
          if (this.s != a.s) {
            BigInteger.ZERO.subTo(r, r);
          }
        }
        squareTo(r) {
          var x = this.abs();
          var i = r.t = 2 * x.t;
          while (--i >= 0) {
            r[i] = 0;
          }
          for (i = 0; i < x.t - 1; ++i) {
            var c = x.am(i, x[i], r, 2 * i, 0, 1);
            if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
              r[i + x.t] -= x.DV;
              r[i + x.t + 1] = 1;
            }
          }
          if (r.t > 0) {
            r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
          }
          r.s = 0;
          r.clamp();
        }
        divRemTo(m, q, r) {
          var pm = m.abs();
          if (pm.t <= 0) {
            return;
          }
          var pt = this.abs();
          if (pt.t < pm.t) {
            if (q != null) {
              q.fromInt(0);
            }
            if (r != null) {
              this.copyTo(r);
            }
            return;
          }
          if (r == null) {
            r = nbi();
          }
          var y = nbi();
          var ts = this.s;
          var ms = m.s;
          var nsh = this.DB - nbits(pm[pm.t - 1]);
          if (nsh > 0) {
            pm.lShiftTo(nsh, y);
            pt.lShiftTo(nsh, r);
          } else {
            pm.copyTo(y);
            pt.copyTo(r);
          }
          var ys = y.t;
          var y0 = y[ys - 1];
          if (y0 == 0) {
            return;
          }
          var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
          var d1 = this.FV / yt;
          var d2 = (1 << this.F1) / yt;
          var e = 1 << this.F2;
          var i = r.t;
          var j = i - ys;
          var t = q == null ? nbi() : q;
          y.dlShiftTo(j, t);
          if (r.compareTo(t) >= 0) {
            r[r.t++] = 1;
            r.subTo(t, r);
          }
          BigInteger.ONE.dlShiftTo(ys, t);
          t.subTo(y, y);
          while (y.t < ys) {
            y[y.t++] = 0;
          }
          while (--j >= 0) {
            var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
            if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
              y.dlShiftTo(j, t);
              r.subTo(t, r);
              while (r[i] < --qd) {
                r.subTo(t, r);
              }
            }
          }
          if (q != null) {
            r.drShiftTo(ys, q);
            if (ts != ms) {
              BigInteger.ZERO.subTo(q, q);
            }
          }
          r.t = ys;
          r.clamp();
          if (nsh > 0) {
            r.rShiftTo(nsh, r);
          }
          if (ts < 0) {
            BigInteger.ZERO.subTo(r, r);
          }
        }
        invDigit() {
          if (this.t < 1) {
            return 0;
          }
          var x = this[0];
          if ((x & 1) == 0) {
            return 0;
          }
          var y = x & 3;
          y = y * (2 - (x & 15) * y) & 15;
          y = y * (2 - (x & 255) * y) & 255;
          y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
          y = y * (2 - x * y % this.DV) % this.DV;
          return y > 0 ? this.DV - y : -y;
        }
        isEven() {
          return (this.t > 0 ? this[0] & 1 : this.s) == 0;
        }
        exp(e, z) {
          if (e > 4294967295 || e < 1) {
            return BigInteger.ONE;
          }
          var r = nbi();
          var r2 = nbi();
          var g = z.convert(this);
          var i = nbits(e) - 1;
          g.copyTo(r);
          while (--i >= 0) {
            z.sqrTo(r, r2);
            if ((e & 1 << i) > 0) {
              z.mulTo(r2, g, r);
            } else {
              var t = r;
              r = r2;
              r2 = t;
            }
          }
          return z.revert(r);
        }
        chunkSize(r) {
          return Math.floor(Math.LN2 * this.DB / Math.log(r));
        }
        toRadix(b) {
          if (b == null) {
            b = 10;
          }
          if (this.signum() == 0 || b < 2 || b > 36) {
            return "0";
          }
          var cs = this.chunkSize(b);
          var a = Math.pow(b, cs);
          var d = nbv(a);
          var y = nbi();
          var z = nbi();
          var r = "";
          this.divRemTo(d, y, z);
          while (y.signum() > 0) {
            r = (a + z.intValue()).toString(b).substr(1) + r;
            y.divRemTo(d, y, z);
          }
          return z.intValue().toString(b) + r;
        }
        fromRadix(s, b) {
          this.fromInt(0);
          if (b == null) {
            b = 10;
          }
          var cs = this.chunkSize(b);
          var d = Math.pow(b, cs);
          var mi = false;
          var j = 0;
          var w = 0;
          for (var i = 0; i < s.length; ++i) {
            var x = intAt(s, i);
            if (x < 0) {
              if (s.charAt(i) == "-" && this.signum() == 0) {
                mi = true;
              }
              continue;
            }
            w = b * w + x;
            if (++j >= cs) {
              this.dMultiply(d);
              this.dAddOffset(w, 0);
              j = 0;
              w = 0;
            }
          }
          if (j > 0) {
            this.dMultiply(Math.pow(b, j));
            this.dAddOffset(w, 0);
          }
          if (mi) {
            BigInteger.ZERO.subTo(this, this);
          }
        }
        fromNumber(a, b, c) {
          if ("number" == typeof b) {
            if (a < 2) {
              this.fromInt(1);
            } else {
              this.fromNumber(a, c);
              if (!this.testBit(a - 1)) {
                this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
              }
              if (this.isEven()) {
                this.dAddOffset(1, 0);
              }
              while (!this.isProbablePrime(b)) {
                this.dAddOffset(2, 0);
                if (this.bitLength() > a) {
                  this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
                }
              }
            }
          } else {
            var x = [];
            var t = a & 7;
            x.length = (a >> 3) + 1;
            b.nextBytes(x);
            if (t > 0) {
              x[0] &= (1 << t) - 1;
            } else {
              x[0] = 0;
            }
            this.fromString(x, 256);
          }
        }
        bitwiseTo(a, op, r) {
          var i;
          var f;
          var m = Math.min(a.t, this.t);
          for (i = 0; i < m; ++i) {
            r[i] = op(this[i], a[i]);
          }
          if (a.t < this.t) {
            f = a.s & this.DM;
            for (i = m; i < this.t; ++i) {
              r[i] = op(this[i], f);
            }
            r.t = this.t;
          } else {
            f = this.s & this.DM;
            for (i = m; i < a.t; ++i) {
              r[i] = op(f, a[i]);
            }
            r.t = a.t;
          }
          r.s = op(this.s, a.s);
          r.clamp();
        }
        changeBit(n, op) {
          var r = BigInteger.ONE.shiftLeft(n);
          this.bitwiseTo(r, op, r);
          return r;
        }
        addTo(a, r) {
          var i = 0;
          var c = 0;
          var m = Math.min(a.t, this.t);
          while (i < m) {
            c += this[i] + a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          if (a.t < this.t) {
            c += a.s;
            while (i < this.t) {
              c += this[i];
              r[i++] = c & this.DM;
              c >>= this.DB;
            }
            c += this.s;
          } else {
            c += this.s;
            while (i < a.t) {
              c += a[i];
              r[i++] = c & this.DM;
              c >>= this.DB;
            }
            c += a.s;
          }
          r.s = c < 0 ? -1 : 0;
          if (c > 0) {
            r[i++] = c;
          } else if (c < -1) {
            r[i++] = this.DV + c;
          }
          r.t = i;
          r.clamp();
        }
        dMultiply(n) {
          this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
          ++this.t;
          this.clamp();
        }
        dAddOffset(n, w) {
          if (n == 0) {
            return;
          }
          while (this.t <= w) {
            this[this.t++] = 0;
          }
          this[w] += n;
          while (this[w] >= this.DV) {
            this[w] -= this.DV;
            if (++w >= this.t) {
              this[this.t++] = 0;
            }
            ++this[w];
          }
        }
        multiplyLowerTo(a, n, r) {
          var i = Math.min(this.t + a.t, n);
          r.s = 0;
          r.t = i;
          while (i > 0) {
            r[--i] = 0;
          }
          for (var j = r.t - this.t; i < j; ++i) {
            r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
          }
          for (var j = Math.min(a.t, n); i < j; ++i) {
            this.am(0, a[i], r, i, 0, n - i);
          }
          r.clamp();
        }
        multiplyUpperTo(a, n, r) {
          --n;
          var i = r.t = this.t + a.t - n;
          r.s = 0;
          while (--i >= 0) {
            r[i] = 0;
          }
          for (i = Math.max(n - this.t, 0); i < a.t; ++i) {
            r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
          }
          r.clamp();
          r.drShiftTo(1, r);
        }
        modInt(n) {
          if (n <= 0) {
            return 0;
          }
          var d = this.DV % n;
          var r = this.s < 0 ? n - 1 : 0;
          if (this.t > 0) {
            if (d == 0) {
              r = this[0] % n;
            } else {
              for (var i = this.t - 1; i >= 0; --i) {
                r = (d * r + this[i]) % n;
              }
            }
          }
          return r;
        }
        millerRabin(t) {
          var n1 = this.subtract(BigInteger.ONE);
          var k = n1.getLowestSetBit();
          if (k <= 0) {
            return false;
          }
          var r = n1.shiftRight(k);
          t = t + 1 >> 1;
          if (t > lowprimes.length) {
            t = lowprimes.length;
          }
          var a = nbi();
          for (var i = 0; i < t; ++i) {
            a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
            var y = a.modPow(r, this);
            if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
              var j = 1;
              while (j++ < k && y.compareTo(n1) != 0) {
                y = y.modPowInt(2, this);
                if (y.compareTo(BigInteger.ONE) == 0) {
                  return false;
                }
              }
              if (y.compareTo(n1) != 0) {
                return false;
              }
            }
          }
          return true;
        }
        square() {
          var r = nbi();
          this.squareTo(r);
          return r;
        }
        gcda(a, callback) {
          var x = this.s < 0 ? this.negate() : this.clone();
          var y = a.s < 0 ? a.negate() : a.clone();
          if (x.compareTo(y) < 0) {
            var t = x;
            x = y;
            y = t;
          }
          var i = x.getLowestSetBit();
          var g = y.getLowestSetBit();
          if (g < 0) {
            callback(x);
            return;
          }
          if (i < g) {
            g = i;
          }
          if (g > 0) {
            x.rShiftTo(g, x);
            y.rShiftTo(g, y);
          }
          var gcda1 = () => {
            if ((i = x.getLowestSetBit()) > 0) {
              x.rShiftTo(i, x);
            }
            if ((i = y.getLowestSetBit()) > 0) {
              y.rShiftTo(i, y);
            }
            if (x.compareTo(y) >= 0) {
              x.subTo(y, x);
              x.rShiftTo(1, x);
            } else {
              y.subTo(x, y);
              y.rShiftTo(1, y);
            }
            if (!(x.signum() > 0)) {
              if (g > 0) {
                y.lShiftTo(g, y);
              }
              setTimeout(function() {
                callback(y);
              }, 0);
            } else {
              setTimeout(gcda1, 0);
            }
          };
          setTimeout(gcda1, 10);
        }
        fromNumberAsync(a, b, c, callback) {
          if ("number" == typeof b) {
            if (a < 2) {
              this.fromInt(1);
            } else {
              this.fromNumber(a, c);
              if (!this.testBit(a - 1)) {
                this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
              }
              if (this.isEven()) {
                this.dAddOffset(1, 0);
              }
              var bnp_1 = this;
              var bnpfn1_1 = function() {
                bnp_1.dAddOffset(2, 0);
                if (bnp_1.bitLength() > a) {
                  bnp_1.subTo(BigInteger.ONE.shiftLeft(a - 1), bnp_1);
                }
                if (bnp_1.isProbablePrime(b)) {
                  setTimeout(function() {
                    callback();
                  }, 0);
                } else {
                  setTimeout(bnpfn1_1, 0);
                }
              };
              setTimeout(bnpfn1_1, 0);
            }
          } else {
            var x = [];
            var t = a & 7;
            x.length = (a >> 3) + 1;
            b.nextBytes(x);
            if (t > 0) {
              x[0] &= (1 << t) - 1;
            } else {
              x[0] = 0;
            }
            this.fromString(x, 256);
          }
        }
      }
      NullExp = function() {
        function NullExp2() {
        }
        NullExp2.prototype.convert = function(x) {
          return x;
        };
        NullExp2.prototype.revert = function(x) {
          return x;
        };
        NullExp2.prototype.mulTo = function(x, y, r) {
          x.multiplyTo(y, r);
        };
        NullExp2.prototype.sqrTo = function(x, r) {
          x.squareTo(r);
        };
        return NullExp2;
      }();
      Classic = function() {
        function Classic2(m) {
          this.m = m;
        }
        Classic2.prototype.convert = function(x) {
          if (x.s < 0 || x.compareTo(this.m) >= 0) {
            return x.mod(this.m);
          } else {
            return x;
          }
        };
        Classic2.prototype.revert = function(x) {
          return x;
        };
        Classic2.prototype.reduce = function(x) {
          x.divRemTo(this.m, null, x);
        };
        Classic2.prototype.mulTo = function(x, y, r) {
          x.multiplyTo(y, r);
          this.reduce(r);
        };
        Classic2.prototype.sqrTo = function(x, r) {
          x.squareTo(r);
          this.reduce(r);
        };
        return Classic2;
      }();
      Montgomery = function() {
        function Montgomery2(m) {
          this.m = m;
          this.mp = m.invDigit();
          this.mpl = this.mp & 32767;
          this.mph = this.mp >> 15;
          this.um = (1 << m.DB - 15) - 1;
          this.mt2 = 2 * m.t;
        }
        Montgomery2.prototype.convert = function(x) {
          var r = nbi();
          x.abs().dlShiftTo(this.m.t, r);
          r.divRemTo(this.m, null, r);
          if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) {
            this.m.subTo(r, r);
          }
          return r;
        };
        Montgomery2.prototype.revert = function(x) {
          var r = nbi();
          x.copyTo(r);
          this.reduce(r);
          return r;
        };
        Montgomery2.prototype.reduce = function(x) {
          while (x.t <= this.mt2) {
            x[x.t++] = 0;
          }
          for (var i = 0; i < this.m.t; ++i) {
            var j = x[i] & 32767;
            var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
            j = i + this.m.t;
            x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
            while (x[j] >= x.DV) {
              x[j] -= x.DV;
              x[++j]++;
            }
          }
          x.clamp();
          x.drShiftTo(this.m.t, x);
          if (x.compareTo(this.m) >= 0) {
            x.subTo(this.m, x);
          }
        };
        Montgomery2.prototype.mulTo = function(x, y, r) {
          x.multiplyTo(y, r);
          this.reduce(r);
        };
        Montgomery2.prototype.sqrTo = function(x, r) {
          x.squareTo(r);
          this.reduce(r);
        };
        return Montgomery2;
      }();
      Barrett = function() {
        function Barrett2(m) {
          this.m = m;
          this.r2 = nbi();
          this.q3 = nbi();
          BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
          this.mu = this.r2.divide(m);
        }
        Barrett2.prototype.convert = function(x) {
          if (x.s < 0 || x.t > 2 * this.m.t) {
            return x.mod(this.m);
          } else if (x.compareTo(this.m) < 0) {
            return x;
          } else {
            var r = nbi();
            x.copyTo(r);
            this.reduce(r);
            return r;
          }
        };
        Barrett2.prototype.revert = function(x) {
          return x;
        };
        Barrett2.prototype.reduce = function(x) {
          x.drShiftTo(this.m.t - 1, this.r2);
          if (x.t > this.m.t + 1) {
            x.t = this.m.t + 1;
            x.clamp();
          }
          this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
          this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
          while (x.compareTo(this.r2) < 0) {
            x.dAddOffset(1, this.m.t + 1);
          }
          x.subTo(this.r2, x);
          while (x.compareTo(this.m) >= 0) {
            x.subTo(this.m, x);
          }
        };
        Barrett2.prototype.mulTo = function(x, y, r) {
          x.multiplyTo(y, r);
          this.reduce(r);
        };
        Barrett2.prototype.sqrTo = function(x, r) {
          x.squareTo(r);
          this.reduce(r);
        };
        return Barrett2;
      }();
      if (j_lm && typeof navigator !== "undefined" && (navigator == null ? void 0 : navigator.appName) == "Microsoft Internet Explorer") {
        BigInteger.prototype.am = am2;
        dbits = 30;
      } else if (j_lm && (navigator == null ? void 0 : navigator.appName) != "Netscape") {
        BigInteger.prototype.am = am1;
        dbits = 26;
      } else {
        BigInteger.prototype.am = am3;
        dbits = 28;
      }
      BigInteger.prototype.DB = dbits;
      BigInteger.prototype.DM = (1 << dbits) - 1;
      BigInteger.prototype.DV = 1 << dbits;
      BI_FP = 52;
      BigInteger.prototype.FV = Math.pow(2, BI_FP);
      BigInteger.prototype.F1 = BI_FP - dbits;
      BigInteger.prototype.F2 = 2 * dbits - BI_FP;
      BI_RC = [];
      rr = "0".charCodeAt(0);
      for (vv = 0; vv <= 9; ++vv) {
        BI_RC[rr++] = vv;
      }
      rr = "a".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv) {
        BI_RC[rr++] = vv;
      }
      rr = "A".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv) {
        BI_RC[rr++] = vv;
      }
      BigInteger.ZERO = nbv(0);
      BigInteger.ONE = nbv(1);
      class Arcfour {
        constructor() {
          this.i = 0;
          this.j = 0;
          this.S = [];
        }
        init(key) {
          var i;
          var j;
          var t;
          for (i = 0; i < 256; ++i) {
            this.S[i] = i;
          }
          j = 0;
          for (i = 0; i < 256; ++i) {
            j = j + this.S[i] + key[i % key.length] & 255;
            t = this.S[i];
            this.S[i] = this.S[j];
            this.S[j] = t;
          }
          this.i = 0;
          this.j = 0;
        }
        next() {
          var t;
          this.i = this.i + 1 & 255;
          this.j = this.j + this.S[this.i] & 255;
          t = this.S[this.i];
          this.S[this.i] = this.S[this.j];
          this.S[this.j] = t;
          return this.S[t + this.S[this.i] & 255];
        }
      }
      rng_psize = 256;
      rng_pool = null;
      if (rng_pool == null) {
        rng_pool = [];
        rng_pptr = 0;
        t = void 0;
        if ((window == null ? void 0 : window.crypto) && (window == null ? void 0 : window.crypto.getRandomValues)) {
          z = new Uint32Array(256);
          window == null ? void 0 : window.crypto.getRandomValues(z);
          for (t = 0; t < z.length; ++t) {
            rng_pool[rng_pptr++] = z[t] & 255;
          }
        }
        onMouseMoveListener_1 = function(ev) {
          this.count = this.count || 0;
          if (this.count >= 256 || rng_pptr >= rng_psize) {
            if (window == null ? void 0 : window.removeEventListener) {
              window == null ? void 0 : window.removeEventListener("mousemove", onMouseMoveListener_1, false);
            } else if (window == null ? void 0 : window.detachEvent) {
              window == null ? void 0 : window.detachEvent("onmousemove", onMouseMoveListener_1);
            }
            return;
          }
          try {
            var mouseCoordinates = ev.x + ev.y;
            rng_pool[rng_pptr++] = mouseCoordinates & 255;
            this.count += 1;
          } catch (e) {
          }
        };
        if (window == null ? void 0 : window.addEventListener) {
          window == null ? void 0 : window.addEventListener("mousemove", onMouseMoveListener_1, false);
        } else if (window == null ? void 0 : window.attachEvent) {
          window == null ? void 0 : window.attachEvent("onmousemove", onMouseMoveListener_1);
        }
      }
      class SecureRandom {
        constructor() {
        }
        nextBytes(ba) {
          for (var i = 0; i < ba.length; ++i) {
            ba[i] = rng_get_byte();
          }
        }
      }
      class RSAKey {
        constructor() {
          this.n = null;
          this.e = 0;
          this.d = null;
          this.p = null;
          this.q = null;
          this.dmp1 = null;
          this.dmq1 = null;
          this.coeff = null;
        }
        doPublic(x) {
          return x.modPowInt(this.e, this.n);
        }
        doPrivate(x) {
          if (this.p == null || this.q == null) {
            return x.modPow(this.d, this.n);
          }
          var xp = x.mod(this.p).modPow(this.dmp1, this.p);
          var xq = x.mod(this.q).modPow(this.dmq1, this.q);
          while (xp.compareTo(xq) < 0) {
            xp = xp.add(this.p);
          }
          return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);
        }
        setPublic(N, E) {
          if (N != null && E != null && N.length > 0 && E.length > 0) {
            this.n = parseBigInt(N, 16);
            this.e = parseInt(E, 16);
          } else {
            console.error("Invalid RSA public key");
          }
        }
        encrypt(text) {
          var m = pkcs1pad2(text, this.n.bitLength() + 7 >> 3);
          if (m == null) {
            return null;
          }
          var c = this.doPublic(m);
          if (c == null) {
            return null;
          }
          var h = c.toString(16);
          if ((h.length & 1) == 0) {
            return h;
          } else {
            return "0" + h;
          }
        }
        encryptLong(text) {
          var _this = this;
          var maxLength = (this.n.bitLength() + 7 >> 3) - 11;
          try {
            var ct_1 = "";
            if (text.length > maxLength) {
              var lt = text.match(/.{1,117}/g);
              lt.forEach(function(entry) {
                var t1 = _this.encrypt(entry);
                ct_1 += t1;
              });
              return hex2b64(ct_1);
            }
            var t = this.encrypt(text);
            var y = hex2b64(t);
            return y;
          } catch (ex) {
            return false;
          }
        }
        decryptLong(text) {
          var _this = this;
          var maxLength = this.n.bitLength() + 7 >> 3;
          text = b64tohex(text);
          try {
            if (text.length > maxLength) {
              var ct_2 = "";
              var lt = text.match(/.{1,256}/g);
              lt.forEach(function(entry) {
                var t1 = _this.decrypt(entry);
                ct_2 += t1;
              });
              return ct_2;
            }
            var y = this.decrypt(text);
            return y;
          } catch (ex) {
            return false;
          }
        }
        setPrivate(N, E, D) {
          if (N != null && E != null && N.length > 0 && E.length > 0) {
            this.n = parseBigInt(N, 16);
            this.e = parseInt(E, 16);
            this.d = parseBigInt(D, 16);
          } else {
            console.error("Invalid RSA private key");
          }
        }
        setPrivateEx(N, E, D, P, Q, DP, DQ, C) {
          if (N != null && E != null && N.length > 0 && E.length > 0) {
            this.n = parseBigInt(N, 16);
            this.e = parseInt(E, 16);
            this.d = parseBigInt(D, 16);
            this.p = parseBigInt(P, 16);
            this.q = parseBigInt(Q, 16);
            this.dmp1 = parseBigInt(DP, 16);
            this.dmq1 = parseBigInt(DQ, 16);
            this.coeff = parseBigInt(C, 16);
          } else {
            console.error("Invalid RSA private key");
          }
        }
        generate(B, E) {
          var rng = new SecureRandom();
          var qs = B >> 1;
          this.e = parseInt(E, 16);
          var ee = new BigInteger(E, 16);
          for (; ; ) {
            for (; ; ) {
              this.p = new BigInteger(B - qs, 1, rng);
              if (this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.p.isProbablePrime(10)) {
                break;
              }
            }
            for (; ; ) {
              this.q = new BigInteger(qs, 1, rng);
              if (this.q.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.q.isProbablePrime(10)) {
                break;
              }
            }
            if (this.p.compareTo(this.q) <= 0) {
              var t = this.p;
              this.p = this.q;
              this.q = t;
            }
            var p1 = this.p.subtract(BigInteger.ONE);
            var q1 = this.q.subtract(BigInteger.ONE);
            var phi = p1.multiply(q1);
            if (phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {
              this.n = this.p.multiply(this.q);
              this.d = ee.modInverse(phi);
              this.dmp1 = this.d.mod(p1);
              this.dmq1 = this.d.mod(q1);
              this.coeff = this.q.modInverse(this.p);
              break;
            }
          }
        }
        decrypt(ctext) {
          var c = parseBigInt(ctext, 16);
          var m = this.doPrivate(c);
          if (m == null) {
            return null;
          }
          return pkcs1unpad2(m, this.n.bitLength() + 7 >> 3);
        }
        generateAsync(B, E, callback) {
          var rng = new SecureRandom();
          var qs = B >> 1;
          this.e = parseInt(E, 16);
          var ee = new BigInteger(E, 16);
          var rsa = this;
          var loop1 = () => {
            var loop4 = () => {
              if (rsa.p.compareTo(rsa.q) <= 0) {
                var t = rsa.p;
                rsa.p = rsa.q;
                rsa.q = t;
              }
              var p1 = rsa.p.subtract(BigInteger.ONE);
              var q1 = rsa.q.subtract(BigInteger.ONE);
              var phi = p1.multiply(q1);
              if (phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {
                rsa.n = rsa.p.multiply(rsa.q);
                rsa.d = ee.modInverse(phi);
                rsa.dmp1 = rsa.d.mod(p1);
                rsa.dmq1 = rsa.d.mod(q1);
                rsa.coeff = rsa.q.modInverse(rsa.p);
                setTimeout(function() {
                  callback();
                }, 0);
              } else {
                setTimeout(loop1, 0);
              }
            };
            var loop3 = () => {
              rsa.q = nbi();
              rsa.q.fromNumberAsync(qs, 1, rng, function() {
                rsa.q.subtract(BigInteger.ONE).gcda(ee, function(r) {
                  if (r.compareTo(BigInteger.ONE) == 0 && rsa.q.isProbablePrime(10)) {
                    setTimeout(loop4, 0);
                  } else {
                    setTimeout(loop3, 0);
                  }
                });
              });
            };
            var loop2 = () => {
              rsa.p = nbi();
              rsa.p.fromNumberAsync(B - qs, 1, rng, function() {
                rsa.p.subtract(BigInteger.ONE).gcda(ee, function(r) {
                  if (r.compareTo(BigInteger.ONE) == 0 && rsa.p.isProbablePrime(10)) {
                    setTimeout(loop3, 0);
                  } else {
                    setTimeout(loop2, 0);
                  }
                });
              });
            };
            setTimeout(loop2, 0);
          };
          setTimeout(loop1, 0);
        }
      }
      class JSEncryptRSAKey extends RSAKey {
        constructor(key = "") {
          super();
          if (key) {
            if (typeof key === "string") {
              this.parseKey(key);
            } else if (this.hasPrivateKeyProperty(key) || this.hasPublicKeyProperty(key)) {
              this.parsePropertiesFrom(key);
            }
          }
        }
        parseKey(pem) {
          try {
            var modulus = 0;
            var public_exponent = 0;
            var reHex = /^\s*(?:[0-9A-Fa-f][0-9A-Fa-f]\s*)+$/;
            var der = reHex.test(pem) ? Hex.decode(pem) : Base64.unarmor(pem);
            var asn1 = ASN1.decode(der);
            if (asn1.sub.length === 3) {
              asn1 = asn1.sub[2].sub[0];
            }
            if (asn1.sub.length === 9) {
              modulus = asn1.sub[1].getHexStringValue();
              this.n = parseBigInt(modulus, 16);
              public_exponent = asn1.sub[2].getHexStringValue();
              this.e = parseInt(public_exponent, 16);
              var private_exponent = asn1.sub[3].getHexStringValue();
              this.d = parseBigInt(private_exponent, 16);
              var prime1 = asn1.sub[4].getHexStringValue();
              this.p = parseBigInt(prime1, 16);
              var prime2 = asn1.sub[5].getHexStringValue();
              this.q = parseBigInt(prime2, 16);
              var exponent1 = asn1.sub[6].getHexStringValue();
              this.dmp1 = parseBigInt(exponent1, 16);
              var exponent2 = asn1.sub[7].getHexStringValue();
              this.dmq1 = parseBigInt(exponent2, 16);
              var coefficient = asn1.sub[8].getHexStringValue();
              this.coeff = parseBigInt(coefficient, 16);
            } else if (asn1.sub.length === 2) {
              var bit_string = asn1.sub[1];
              var sequence = bit_string.sub[0];
              modulus = sequence.sub[0].getHexStringValue();
              this.n = parseBigInt(modulus, 16);
              public_exponent = sequence.sub[1].getHexStringValue();
              this.e = parseInt(public_exponent, 16);
            } else {
              return false;
            }
            return true;
          } catch (ex) {
            return false;
          }
        }
        hasPublicKeyProperty(obj) {
          obj = obj || {};
          return obj.hasOwnProperty("n") && obj.hasOwnProperty("e");
        }
        hasPrivateKeyProperty(obj) {
          obj = obj || {};
          return obj.hasOwnProperty("n") && obj.hasOwnProperty("e") && obj.hasOwnProperty("d") && obj.hasOwnProperty("p") && obj.hasOwnProperty("q") && obj.hasOwnProperty("dmp1") && obj.hasOwnProperty("dmq1") && obj.hasOwnProperty("coeff");
        }
        parsePropertiesFrom(obj) {
          this.n = obj.n;
          this.e = obj.e;
          if (obj.hasOwnProperty("d")) {
            this.d = obj.d;
            this.p = obj.p;
            this.q = obj.q;
            this.dmp1 = obj.dmp1;
            this.dmq1 = obj.dmq1;
            this.coeff = obj.coeff;
          }
        }
      }
      JSEncrypt = function(options) {
        options = options || {};
        this.default_key_size = parseInt(options.default_key_size, 10) || 1024;
        this.default_public_exponent = options.default_public_exponent || "010001";
        this.log = options.log || false;
        this.key = null;
      };
      JSEncrypt.prototype.setKey = function(key) {
        if (this.log && this.key) {
          console.warn("A key was already set, overriding existing.");
        }
        this.key = new JSEncryptRSAKey(key);
      };
      JSEncrypt.prototype.setPrivateKey = function(privkey) {
        this.setKey(privkey);
      };
      JSEncrypt.prototype.setPublicKey = function(pubkey) {
        this.setKey(pubkey);
      };
      JSEncrypt.prototype.decrypt = function(str) {
        try {
          return this.getKey().decrypt(b64tohex(str));
        } catch (ex) {
          return false;
        }
      };
      JSEncrypt.prototype.encrypt = function(str) {
        try {
          return hex2b64(this.getKey().encrypt(str));
        } catch (ex) {
          return false;
        }
      };
      JSEncrypt.prototype.encryptLong = function(str) {
        try {
          var encrypted = this.getKey().encryptLong(str) || "";
          var uncrypted = this.getKey().decryptLong(encrypted) || "";
          var count = 0;
          var reg = /null$/g;
          while (reg.test(uncrypted)) {
            count++;
            encrypted = this.getKey().encryptLong(str) || "";
            uncrypted = this.getKey().decryptLong(encrypted) || "";
            if (count > 10) {
              break;
            }
          }
          return encrypted;
        } catch (ex) {
          return false;
        }
      };
      JSEncrypt.prototype.getKey = function(cb) {
        if (!this.key) {
          this.key = new JSEncryptRSAKey();
          if (cb && {}.toString.call(cb) === "[object Function]") {
            this.key.generateAsync(this.default_key_size, this.default_public_exponent, cb);
            return;
          }
          this.key.generate(this.default_key_size, this.default_public_exponent);
        }
        return this.key;
      };
      JSEncrypt.version = "3.1.4";
    }
    encryptlong_default = JSEncrypt;
  }
});

// node_modules/@cloudbase/oauth/dist/esm/utils/index.js
var deepClone, getPathName;
var init_utils = __esm({
  "node_modules/@cloudbase/oauth/dist/esm/utils/index.js"() {
    deepClone = (value) => {
      const clone = (copiedValue) => {
        for (const key in value) {
          if (value.hasOwnProperty(key)) {
            copiedValue[key] = deepClone(value[key]);
          }
        }
        return copiedValue;
      };
      const type = value === null || value === void 0 ? "NullOrUndefined" : Object.prototype.toString.call(value).slice(8, -1);
      if ([
        "Int8Array",
        "Uint8Array",
        "Uint8ClampedArray",
        "Int16Array",
        "Uint16Array",
        "Int32Array",
        "Uint32Array",
        "Float32Array",
        "Float64Array",
        "BigInt64Array",
        "BigUint64Array"
      ].includes(type)) {
        return value.slice();
      }
      switch (type) {
        case "Object":
          return clone(Object.create(Object.getPrototypeOf(value)));
        case "Array":
          return clone([]);
        case "Date":
          return new Date(value.valueOf());
        case "RegExp":
          return new RegExp(value.source, (value.global ? "g" : "") + (value.ignoreCase ? "i" : "") + (value.multiline ? "m" : "") + (value.sticky ? "y" : "") + (value.unicode ? "u" : ""));
        default:
          return value;
      }
    };
    getPathName = (url) => {
      const regex = /^(?:http(s)?:\/\/[^\/]+)?(\/[^\?#]*)/;
      const match = url.match(regex);
      if (match) {
        return match[2] || "";
      }
      return "";
    };
  }
});

// node_modules/@cloudbase/oauth/dist/esm/utils/encrypt.js
var encrypt_exports = {};
__export(encrypt_exports, {
  getEncryptInfo: () => getEncryptInfo
});
var getEncryptInfo;
var init_encrypt = __esm({
  "node_modules/@cloudbase/oauth/dist/esm/utils/encrypt.js"() {
    init_encryptlong();
    init_utils();
    getEncryptInfo = ({ publicKey = "", payload = {} } = {}) => {
      if (!publicKey)
        return "";
      try {
        const params = deepClone(payload);
        const rsaInstance = new encryptlong_default();
        rsaInstance.setPublicKey(publicKey);
        const encrypted = rsaInstance.encryptLong(typeof params === "object" ? JSON.stringify(params) : params);
        return encrypted;
      } catch (error) {
        console.error("encrypt error:", error);
      }
      return "";
    };
  }
});

export {
  deepClone,
  getPathName,
  init_utils,
  getEncryptInfo,
  encrypt_exports,
  init_encrypt
};
//# sourceMappingURL=chunk-UG3QWNPE.js.map
